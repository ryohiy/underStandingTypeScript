*2-10_型の利用
js->動的片付け言語
jsのコアなdata型
number すべての数値
string すべての文字列
boolean ture,false
object jsの全objectのこと。objectの型をより明確に定義する事が可能
Array JSの全てのArray。要素の型は柔軟にも厳格にも指定出来る。

*Tuple型　
vanillaJSにはない、TS用の型。ほかの言語(Python等)にはあったりする
TupleはArrayの亜種みたいので、要素の長さが固定された配列の事
定義した配列に対して,誤った数の要素の配列を入れようとしたり、
要素の型が違っていると、Errを出して教えて来るのが良い点

*Enum型（列挙型）
これもvanillaJSにはなくて、他の言語にはあったりするTSが追加してくれる型
定数の集合に対して名前をつけて管理することが出来る。
あんまり見慣れない定義の方法で、以下のようにする。
enum{NEW,OLD}

*any型
プログラマーの敗北。つかう事は避けるべき。
TSはこれが使われているものをchkしない。

#sec3-32TSのコンパイラ
#sec3-42プロジェクト全体のコンパイル方法
tsc --init
ルートフォルダが現在のフォルダであることを
確認し、上記のcmdを実行すると、
tsconfig.jsonというファイルを作る
このtsconfig.jsonがあるフォルダ、
そのサブフォルダにあるもの全てが
TSによって管理されるべきであるという事
をこのファイルは意味する。

とにもかくにも、これでproject全体をtscで観れる
ようになるので、tscコマンドをたたけば、
TSが自動的に.ts拡張子のファイルを全て探してコンパイル
してくれるようになるため、tsファイルが複数ある時に便利。

また tsc --watchでもtsconfig.jsonは有効、やはり
逐一行うよりも便利。
npmの詳細な使い方も正直知りたいので、それも早めに手をつけよう。

tscのsourceMap機能は個人的に便利だと思った。
普通コンパイルしたらjsファイルになるけど、この機能をonにしておけば
tsファイル作られ、かつこれに対してブレークポイントを作ってデバッグも出来る。
本番環境では絶対必要ようないけど、dev環境なら全然使っていい気がする。
removeCommentsは会社の設定でも使ってもいいなら使いたいと思った。

tsファイルではコメント欲しいけど（開発者の為に）、別にコンパイル後のjsファイルに
コメントがある必要はないなって思うし。イイ！

noEmitOnErrorをtrueにすると、tsErrがあるとコンパイルが出来ない。
逆にいえばわざわざ書かなければjsのコンパイルは出来る。

厳密な型のチェックが出来るオプション（Strict TypeChecking Options）というものが
あるけど、現時点の自分は今あるもので十分すぎる。

sec4-49~
let
const
var
varはグローバルか関数スコープのどちらかしかない
letは？
ブロックスコープアいう概念を利用している

varはがばがば過ぎる。

sec5-58
*オブジェクト指向プログラミング
(Object-oriented Programming,OOP)
コードで現実世界のものに似せたものをObjectとして
扱う。

→我々開発者が、どうやって大きなものを1つ1つ分解して
自分たちに撮って分かりやすくするかという1つの手法。

Object->コードで扱う具体的なもの
クラス->objの設計図になるもの
インスタンス->クラスを利用して作られたobj

クラスを利用することで、同じ定義や、同じメソッドをもつobjを簡単に
複製することが出来る。

*59 最初のクラス（実践）
「sec59-class.ts」で簡単にメモ

*60javaScriptへのコンパイル
「sec59-class.ts」で簡単にメモ
tsconfigでes2016->es5へコンパイルされるjsを変更すると、
全然違うjsが生成される。
これは以前のjsで使われていたクラスの定義方法。

tsはtargetの指定を変更すればそれにあった方法でコードを
実現できるようにコンパイルしてくれる。それが重要。

*61 コンストラクタ関数 this キーワード

「sec59-class.ts」で簡単に実践

constructorメソッドはクラスのインスタンスを作成した時だけ呼び出される
初期化用の関数。

「this」 classから作成された具体的なインスタンスを参照する。
例えば「name」というpropにアクセスしたいときにthisを使わずに
そのまま書くとwindowオブジェクトにあるグローバル変数にアクセスしてしまう。

「this」は基本的にその関数を呼び出すための責任があるobjを参照する。
->thisは「.」の前のobjを参照している。
exを「sec59-class.ts」に記述。
要するに
hoge.funk()
でhoge内のname というprop にはアクセス出来るが
hogeCopy = hoge

hogeCopy.describe()だと、
describe()内のthisはhogeCopyのname propを探してしまう。
これは動作的に正しいため、こういう使い方したいならhogeCopyに
name のpropを用意してあげなさい！てこと

*62 private public 修飾子
1つの事をするには明確な１つのやり方だけがある方がいい。
クラスの使い方は明確に１つだけあるようにすべき。
なぜなら大規模開発の際に、人それぞれ手法が違うと困るから。

private クラスの内部からのみアクセスが出来る。
つまり作成されたobjの内部からのみアクセスが出来る。
publicはデフォルトの状態。

*63 プロパティ初期化のショートカット構文
constructor等、クラス内で利用する変数をprivateのもの
を定義したい場合、2重で定義しなければいけないのか？
また、constructorで毎回初期化を記述しなければいけないのか？
↓
class hoge{
private name;
private id;

constructor(name,id){
this.name = name;
this.id = id;
//constructorで値の初期化処理をしてる
}

}
constructorに渡したい引数が増えると、変数の定義もその都度書いて
あげないといけない？

tsでは、以下のように書くことで定義する場所を1箇所で済ませる事が出来る。
...
constructor(private name,private id, public age){
処理が入る
}
...
また、上記のように記述すると、これらの引数をパラメータとして取得
するだけでなく、このパラメータと全く同じ名前でプロパティを定義してくれる。
（これらの初期値はクラスをnewしてインスタンスを作成した際に渡す値となる。）
これは特別な命令である。

一応実践した結果を「sec59-class.ts」に記述する。
*sec5-64 readonlyプロパティ
読み取り専用のプロパティ。
初期化した後、変更しようとするとtsのエラーが起きる、
readonlyプロパティをつける事で、開発者の意図をクリアに伝えることが出来る。

プロトタイプというjsの概念、これを学んでおくことは損ではないのでまた
資料から学習をする。

*小テスト4
ささっとやって今日はok!
*sec5-64 継承
クラスの継承
ちょっとコードにガシガシ書いて行こう
※継承はひとつのクラスからしか出来ない
継承元となるクラスをベースクラスという。

継承先のクラス（サブクラス）にconstructorがない場合
★ベースクラスのコンストラクタが自動的に使われる！

サブクラスに独自にconstructorを定義する事も出来る
例えば、ベースクラスのIDというpropは、サブクラスでは固定なものかもしれない。
その時constructorをサブクラスで定義し、superを利用してIDに固定の値を渡して
あげれば、サブクラスで利用する必要がないものをnewする時に指定する必要がなくなる

また、サブクラスだけで、ベースクラスにはないpropを定義したいケースもあるはず。
こういった時は、まずサブクラスのconstructorに新しく引数は定義しなくてはいけない。
（そうしないとnewした時に何の値も入ってこなくなっちゃうからね）
この時、private等の修飾子をつけるとプロパティも定義できる、といったショートカット構文
がある。しかし、この場合はsuperを先に呼び出さなければいけない事を明確にするために
あえて冗長ともとれる書き方をした方がいい。(もちろんしなくてもエラーになる訳ではない)

constructorは上記のように特殊だが、後はサブクラスだけにベースクラスには
ないメソッドを追加したり、普段使っているclassと変わらず利用できる。

constructorだけは少し気をつけましょう。ということ。です。
sec5-66 protected
ベースクラスで定義したプロパティを、それを継承したサブクラスでも
アクセス出来るようにしたい場合、privateではなく、protectedを利用する。

sec5-67 Getter&Setter
クラス・プロパティ、継承はモダンなJSでもサポートされている。
しかしprotected,private,publicのようなものはTSだけ。

getter,setterについて説明する。
これを説明するために、Departmentクラスを継承したaccountingDepartment
クラスを作るので、sec59-class.tsファイルを参考にしてほしい。
ここで、最新のreportを所持するlastReportというプロパティを用意する。

lastReportはprivateなプロパティなので、メソッドの内部からthisを使ってアクセス
出来る、しかし外部からはアクセス出来ない。privateなプロパティだから。

これを「getter」を使うことで外部からアクセス出来るようにする事が出来る。

getterは基本的に「値を取得するメソッド」。
TSで定義する際はgetキーワードを使って、メソッドのように定義する。

何の意味があるか。カプセル化のような仕組みである。利用できる
範囲を絞る事に意味がある。
また、例えば、このプロパティがそもそも存在するかどうかのチェックを
する事も出来る。実際lastReportプロパティはundefinedの可能性があるため
（受け取るreportの配列が空配列の可能性がある。）必要な処理。

getterを外部で使用する際は、プロパティを利用するように行う。

次に「setter」。ようはgetterと逆の事をやりたいてこと。
ひとつ気をつける事として、getterとsetterは「同じ名前で定義する」と良いかもしれない。
それか、頭に「get」,「set」だけつけて他はすべてそのまま。みたいな。
自分的には後者の方が好きかな。

getとsetは、クラスのプロパティを操作する時に利用していこう。
直近の業務で、まぁでもあれはbuilderパターンだからいいのか。
考えて整理出来るところには積極的に手を入れていこう。

sec5-68 staticメソッド&プロパティ
jsのes6、TSで利用する事が出来るようになった構文。
静的プロパティ、静的メソッドと同義。

直接クラスに対してアクセスするため、オブジェクトを作る必要がない。
例として、JSにはMathという静的なクラスが組み込まれていて、
Mathに関係する定数、例えばMath.PI（円周率）を呼び出せる。
また、staticメソッドの例としてはMath.pow（2乗、べき乗の計算）をするものがある。

論理的に近い機能をまとめるグループ化の仕組みとして名前空間のような役割を
はたしている、といえる。

プロパティの定義や、メソッドの定義では基本的に普通にそれらを定義しstaticキーワード
をつけてあげれば利用できる。

注意点として、クラス内のstaticでない部分から（constructor,やクラス内のメソッド。
分かりやすい区別としてthisを使って呼出すスコープ）ではアクセス出来ない。

なぜならthisはくらすをもとに作成されたインスタンスを指しているため。

staticなプロパティはインスタンスからアクセスできないようにされていて、
これは本来の概念として、インスタンスとは切り離して存在させるものだから。

もし、クラス内でstaticプロパティやメソッドにアクセスしたいなら
クラス内であっても具体的なクラス名を指定してアクセスする。
（ex:Departmentクラス内で、Department.yearでそのstaticプロパティに
アクセスする。）
sec5-69 abstract


sec7 Generics
sec7-98 keyofの制約
関数にobjとそのプロパティを明示的に渡したい時、keyofの制約で表現する事が出来る。
generics.tsに例を記述する。


sec7-100
ジェネリック型のまとめ
ジェネリック型はフレキシブルに制約をつける事が出来る。
本当にたくさんの事を決める事が出来るため、今後の例題を通して
勉強していこう。

sec8-112クラスデコレ―タによるクラスの変更
デコレ―タの章は聞くだけで済ませていた。正直あまり分かっていないが、
まぁ必須項目という感じでもなさそうなのでササっとすませる。
聞き流しておいて今後のフックになればくらいの触りにしておく。







