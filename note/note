*2-10_型の利用
js->動的片付け言語
jsのコアなdata型
number すべての数値
string すべての文字列
boolean ture,false
object jsの全objectのこと。objectの型をより明確に定義する事が可能
Array JSの全てのArray。要素の型は柔軟にも厳格にも指定出来る。

*Tuple型　
vanillaJSにはない、TS用の型。ほかの言語(Python等)にはあったりする
TupleはArrayの亜種みたいので、要素の長さが固定された配列の事
定義した配列に対して,誤った数の要素の配列を入れようとしたり、
要素の型が違っていると、Errを出して教えて来るのが良い点

*Enum型（列挙型）
これもvanillaJSにはなくて、他の言語にはあったりするTSが追加してくれる型
定数の集合に対して名前をつけて管理することが出来る。
あんまり見慣れない定義の方法で、以下のようにする。
enum{NEW,OLD}

*any型
プログラマーの敗北。つかう事は避けるべき。
TSはこれが使われているものをchkしない。

#sec3-32TSのコンパイラ
#sec3-42プロジェクト全体のコンパイル方法
tsc --init
ルートフォルダが現在のフォルダであることを
確認し、上記のcmdを実行すると、
tsconfig.jsonというファイルを作る
このtsconfig.jsonがあるフォルダ、
そのサブフォルダにあるもの全てが
TSによって管理されるべきであるという事
をこのファイルは意味する。

とにもかくにも、これでproject全体をtscで観れる
ようになるので、tscコマンドをたたけば、
TSが自動的に.ts拡張子のファイルを全て探してコンパイル
してくれるようになるため、tsファイルが複数ある時に便利。

また tsc --watchでもtsconfig.jsonは有効、やはり
逐一行うよりも便利。
npmの詳細な使い方も正直知りたいので、それも早めに手をつけよう。

tscのsourceMap機能は個人的に便利だと思った。
普通コンパイルしたらjsファイルになるけど、この機能をonにしておけば
tsファイル作られ、かつこれに対してブレークポイントを作ってデバッグも出来る。
本番環境では絶対必要ようないけど、dev環境なら全然使っていい気がする。
removeCommentsは会社の設定でも使ってもいいなら使いたいと思った。

tsファイルではコメント欲しいけど（開発者の為に）、別にコンパイル後のjsファイルに
コメントがある必要はないなって思うし。イイ！

noEmitOnErrorをtrueにすると、tsErrがあるとコンパイルが出来ない。
逆にいえばわざわざ書かなければjsのコンパイルは出来る。

厳密な型のチェックが出来るオプション（Strict TypeChecking Options）というものが
あるけど、現時点の自分は今あるもので十分すぎる。

sec4-49~
let
const
var
varはグローバルか関数スコープのどちらかしかない
letは？
ブロックスコープアいう概念を利用している

varはがばがば過ぎる。

sec5-58
*オブジェクト指向プログラミング
(Object-oriented Programming,OOP)
コードで現実世界のものに似せたものをObjectとして
扱う。

→我々開発者が、どうやって大きなものを1つ1つ分解して
自分たちに撮って分かりやすくするかという1つの手法。

Object->コードで扱う具体的なもの
クラス->objの設計図になるもの
インスタンス->クラスを利用して作られたobj

クラスを利用することで、同じ定義や、同じメソッドをもつobjを簡単に
複製することが出来る。

*59 最初のクラス（実践）
「sec59-class.ts」で簡単にメモ

*60javaScriptへのコンパイル
「sec59-class.ts」で簡単にメモ
tsconfigでes2016->es5へコンパイルされるjsを変更すると、
全然違うjsが生成される。
これは以前のjsで使われていたクラスの定義方法。

tsはtargetの指定を変更すればそれにあった方法でコードを
実現できるようにコンパイルしてくれる。それが重要。

*61 コンストラクタ関数 this キーワード

「sec59-class.ts」で簡単に実践

constructorメソッドはクラスのインスタンスを作成した時だけ呼び出される
初期化用の関数。

「this」 classから作成された具体的なインスタンスを参照する。
例えば「name」というpropにアクセスしたいときにthisを使わずに
そのまま書くとwindowオブジェクトにあるグローバル変数にアクセスしてしまう。

「this」は基本的にその関数を呼び出すための責任があるobjを参照する。
->thisは「.」の前のobjを参照している。
exを「sec59-class.ts」に記述。
要するに
hoge.funk()
でhoge内のname というprop にはアクセス出来るが
hogeCopy = hoge

hogeCopy.describe()だと、
describe()内のthisはhogeCopyのname propを探してしまう。
これは動作的に正しいため、こういう使い方したいならhogeCopyに
name のpropを用意してあげなさい！てこと

*62 private public 修飾子
1つの事をするには明確な１つのやり方だけがある方がいい。
クラスの使い方は明確に１つだけあるようにすべき。
なぜなら大規模開発の際に、人それぞれ手法が違うと困るから。

private クラスの内部からのみアクセスが出来る。
つまり作成されたobjの内部からのみアクセスが出来る。
publicはデフォルトの状態。

*63 プロパティ初期化のショートカット構文
constructor等、クラス内で利用する変数をprivateのもの
を定義したい場合、2重で定義しなければいけないのか？
また、constructorで毎回初期化を記述しなければいけないのか？
↓
class hoge{
private name;
private id;

constructor(name,id){
this.name = name;
this.id = id;
//constructorで値の初期化処理をしてる
}

}
constructorに渡したい引数が増えると、変数の定義もその都度書いて
あげないといけない？

tsでは、以下のように書くことで定義する場所を1箇所で済ませる事が出来る。
...
constructor(private name,private id, public age){
処理が入る
}
...
また、上記のように記述すると、これらの引数をパラメータとして取得
するだけでなく、このパラメータと全く同じ名前でプロパティを定義してくれる。
（これらの初期値はクラスをnewしてインスタンスを作成した際に渡す値となる。）
これは特別な命令である。

一応実践した結果を「sec59-class.ts」に記述する。
*sec5-64 readonlyプロパティ
読み取り専用のプロパティ。
初期化した後、変更しようとするとtsのエラーが起きる、
readonlyプロパティをつける事で、開発者の意図をクリアに伝えることが出来る。

プロトタイプというjsの概念、これを学んでおくことは損ではないのでまた
資料から学習をする。

*小テスト4
ささっとやって今日はok!













